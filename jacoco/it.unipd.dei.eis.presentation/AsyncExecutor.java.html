<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AsyncExecutor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">eis-app</a> &gt; <a href="index.source.html" class="el_package">it.unipd.dei.eis.presentation</a> &gt; <span class="el_source">AsyncExecutor.java</span></div><h1>AsyncExecutor.java</h1><pre class="source lang-java linenums">package it.unipd.dei.eis.presentation;

import it.unipd.dei.eis.core.common.Either;
import it.unipd.dei.eis.core.common.Failure;
import it.unipd.dei.eis.core.common.Success;

import java.io.PrintStream;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.function.Supplier;

/**
 * The AsyncExecutor class is the singleton class that executes the controllers.
 * It contains the execute method.
 */
public class AsyncExecutor {

    /**
     * The ANIMATION field is the animation of the loading thread.
     */
<span class="fc" id="L21">    private static final String[] ANIMATION = {&quot;⠋&quot;, &quot;⠙&quot;, &quot;⠹&quot;, &quot;⠸&quot;, &quot;⠼&quot;, &quot;⠴&quot;, &quot;⠦&quot;, &quot;⠧&quot;, &quot;⠇&quot;, &quot;⠏&quot;};</span>

    /**
     * The ANIMATION_INTERVAL field is the interval between two frames of the animation.
     */
    private static final int ANIMATION_INTERVAL = 100;

    /**
     * The ANSI_GREEN field is the ANSI code for green.
     */
    private static final String ANSI_GREEN = &quot;\u001B[32m&quot;;

    /**
     * The ANSI_RESET field is the ANSI code for reset.
     */
    private static final String ANSI_RESET = &quot;\u001B[0m&quot;;

    /**
     * The instance field is the instance of the AsyncExecutor class.
     */
    private static AsyncExecutor instance;

    /**
     * The loadingThread field is the thread that prints the animation of the loading.
     */
    private Thread loadingThread;

    /**
     * The startTime field is the start time of the loading thread.
     */
    private long startTime;

    /**
     * The AsyncExecutor constructor.
     * It sets the animation of the loading thread.
     */
<span class="fc" id="L57">    private AsyncExecutor() {</span>
<span class="fc" id="L58">        System.setOut(new PrintStream(System.out) {</span>

            /**
             * The println method prints the operation of the controller.
             */
            @Override
            public void println(String x) {
<span class="fc" id="L65">                super.printf(&quot;\r - %s%n&quot;, x);</span>
<span class="fc" id="L66">            }</span>
        });
<span class="fc" id="L68">    }</span>

    /**
     * The getInstance method returns the instance of the AsyncExecutor class.
     *
     * @return the instance of the AsyncExecutor class
     */
    public static synchronized AsyncExecutor getInstance() {
<span class="fc bfc" id="L76" title="All 2 branches covered.">        if (instance == null) {</span>
<span class="fc" id="L77">            instance = new AsyncExecutor();</span>
        }
<span class="fc" id="L79">        return instance;</span>
    }

    /**
     * The abort method aborts the loading thread.
     * Find the cause of the exception and throw a RuntimeException.
     *
     * @param e the exception
     */
    private void abort(Exception e) {
<span class="fc" id="L89">        Throwable throwable = e;</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        while (throwable.getCause() != null) {</span>
<span class="fc" id="L91">            throwable = throwable.getCause();</span>
        }
<span class="fc" id="L93">        loadingThread.interrupt();</span>
        try {
<span class="fc" id="L95">            Thread.sleep(ANIMATION_INTERVAL);</span>
<span class="nc" id="L96">        } catch (InterruptedException ignored) {</span>
<span class="fc" id="L97">        }</span>
<span class="fc" id="L98">        RuntimeException exception = new RuntimeException(</span>
<span class="fc" id="L99">                String.format(</span>
                        &quot;\r[X] Error: %s • %s&quot;,
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">                        throwable.getMessage() == null ? &quot;Unknown error&quot; : throwable.getMessage(),</span>
<span class="fc" id="L102">                        getLoadingTime()</span>
                )
        );
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if (throwable.getMessage() == null) {</span>
<span class="nc" id="L106">            exception.setStackTrace(throwable.getStackTrace());</span>
        } else {
<span class="fc" id="L108">            exception.setStackTrace(new StackTraceElement[]{});</span>
        }
<span class="fc" id="L110">        throw exception;</span>
    }

    /**
     * The execute method executes a function.
     *
     * @param supplier the function to be executed
     * @param name     the name of the function
     */
    public synchronized void execute(Supplier&lt;Either&lt;Failure, Success&gt;&gt; supplier, String name) {
<span class="fc" id="L120">        System.out.printf(&quot;%s:%n&quot;, name);</span>
<span class="fc" id="L121">        startTime = System.currentTimeMillis();</span>
<span class="fc" id="L122">        loadingThread = getLoadingThread();</span>
<span class="fc" id="L123">        loadingThread.start();</span>
        try {
<span class="fc" id="L125">            Either&lt;Failure, Success&gt; result = CompletableFuture.supplyAsync(supplier)</span>
<span class="fc" id="L126">                    .get();</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">            if (result.isFailure()) {</span>
<span class="nc" id="L128">                abort(result.failure.exception);</span>
            }
<span class="fc" id="L130">            loadingThread.interrupt();</span>
<span class="fc" id="L131">            System.out.printf(ANSI_GREEN + &quot;\r[✓] Success • %s%n%n&quot;, getLoadingTime() + ANSI_RESET);</span>
<span class="nc" id="L132">        } catch (InterruptedException | ExecutionException e) {</span>
<span class="nc" id="L133">            abort(e);</span>
<span class="fc" id="L134">        }</span>
<span class="fc" id="L135">    }</span>

    /**
     * The getLoadingThread method returns the loading thread.
     *
     * @return the loading thread
     */
    @SuppressWarnings(&quot;BusyWait&quot;)
    private Thread getLoadingThread() {
<span class="fc" id="L144">        return new Thread(() -&gt; {</span>
<span class="fc" id="L145">            int animIndex = 0;</span>
<span class="fc" id="L146">            while (!Thread.currentThread()</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">                    .isInterrupted()) {</span>
<span class="fc" id="L148">                System.out.printf(&quot;\r[%s] Loading • %s&quot;, ANIMATION[animIndex], getLoadingTime());</span>
<span class="fc" id="L149">                animIndex = (animIndex + 1) % ANIMATION.length;</span>
                try {
<span class="fc" id="L151">                    Thread.sleep(ANIMATION_INTERVAL);</span>
<span class="fc" id="L152">                } catch (InterruptedException e) {</span>
<span class="fc" id="L153">                    Thread.currentThread()</span>
<span class="fc" id="L154">                            .interrupt();</span>
<span class="fc" id="L155">                }</span>
            }
<span class="fc" id="L157">        });</span>
    }

    /**
     * The getLoadingTime method returns the loading time as string.
     *
     * @return the loading time
     */
    private String getLoadingTime() {
<span class="fc" id="L166">        long time = System.currentTimeMillis() - startTime;</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (time &lt; 1000) {</span>
<span class="fc" id="L168">            return String.format(&quot;%d ms&quot;, time);</span>
        }
<span class="fc" id="L170">        return String.format(&quot;%d.%01ds&quot;, time / 1000, (time % 1000) / 100);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>